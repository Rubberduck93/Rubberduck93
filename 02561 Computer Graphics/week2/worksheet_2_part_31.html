<!DOCTYPE html>
<html lang="en">
<head>
    <title> Worksheet 2: Input devices and interaction</title>
    <h1> Worksheet 2: Input devices and interaction</h1>
    <h2> Part 3: Two drawing modes </h2>
    <meta charset="UTF-8">
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aPosition;
        attribute vec4 aColors;

        varying vec4 vColors;

        void main(void)
        {
            gl_Position = aPosition;
            gl_PointSize = 20.0;
            vColors = aColors;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 vColors;
        void main(void)
        {
            gl_FragColor = vColors;
        }
    </script>
    <script type="text/javascript" src="../lib/webgl-utils.js"></script>
    <script type="text/javascript" src="../lib/initShaders.js"></script>
    <script type="text/javascript" src="../lib/MV.js"></script>
</head>
<body>
      <canvas id="gl-canvas" width="512" height="512"  style="border:1px solid #000000;">
      Oops ... your browser doesn't support the HTML5 canvas element
      </canvas>
      <div style="width: 100px; float:left; height:250px; margin:10px">
        <button type="button" onclick="clear_canvas()">CLEAR CANVAS</button>
        <p>Canvas Colors</p>

        <select id="canvas_color_menu" size="7">
        <option value="0">Default</option>
        <option value="1">Black</option>
        <option value="2">Red</option>
        <option value="3">Yellow</option>
        <option value="4">Green</option>
        <option value="5">Blue</option>
        <option value="6">Magenta</option>
        <option value="7">Cyan</option>
        </select>
      </div>


      <div style="width:260px; float:right; height:100px; margin:10px">
        <button type="button" onclick="draw_points()">DRAW POINTS</button>
        <p>Point Colors</p>
        <select id="point_color_menu" size="4">
        <option value="0">Black</option>
        <option value="1">Red</option>
        <option value="2">Green</option>
        <option value="3">Blue</option>
        </select>

        <p> --- </p>
        <button type="button" onclick="draw_triangle()">DRAW TRIANGLE</button>
        <p>Triangle Colors</p>
        <select id="triangle_color_menu" size="4">
        <option value="0">Black</option>
        <option value="1">Red</option>
        <option value="2">Green</option>
        <option value="3">Blue</option>
        </select>
      </div>

</body>
<br/>
<a href="https://rubberduck93.github.io/02561%20Computer%20Graphics/week2/worksheet_2_part_2.html">&lt;&lt; Worksheet 2 Part 2</a>
<a> ||| </a>
<a href="https://rubberduck93.github.io/02561%20Computer%20Graphics/week2/worksheet_2_part_4.html">Worksheet 2 Part 4 &gt;&gt;</a><br />

</html>


<script type="text/javascript">


var canvas_colors = [];


var point_vertices = [];
var point_colors = [];

var triangle_vertices = [];
var triangle_colors = [];
var triangle_indices = [];
var triangle_index = 0;

var canvas_index;


var canvas;
var canvas_menu;
var point_menu;
var triangle_menu;

var gl;
var program;

var draw_points_on = false;
var draw_triangle_on = false;

var maxNumTriangles = 200;
var maxNumVertices  = 3 * maxNumTriangles;

var index = 0;
var point_index = 0;

var aPosition;
var aColors;


window.onload = function init()
{
    canvas = document.getElementById( "gl-canvas" );
    canvas_menu = document.getElementById("canvas_color_menu");
    point_menu = document.getElementById("point_color_menu");
    triangle_menu = document.getElementById("triangle_color_menu");

    gl = WebGLUtils.setupWebGL( canvas );
    if ( !gl ) { alert( "WebGL isn't available" ); }

    program = initShaders( gl, "vertex-shader", "fragment-shader" );
    gl.useProgram( program );

    canvas_menu.addEventListener("click", function() { canvas_index = canvas_menu.selectedIndex; });
    point_menu.addEventListener("click", function() { pointIndex = point_menu.selectedIndex; });
    triangle_menu.addEventListener("click", function() { triangleIndex = triangle_menu.selectedIndex; });

    canvas_colors = [
      vec4(0.3921, 0.5843, 0.9294, 1.0), // default
      vec4(0.0, 0.0, 0.0, 1.0), // black
      vec4(1.0, 0.0, 0.0, 1.0), // red
      vec4(1.0, 1.0, 0.0, 1.0), // yellow
      vec4(0.0, 1.0, 0.0, 1.0), // green
      vec4(0.0, 0.0, 1.0, 1.0), // blue
      vec4(1.0, 0.0, 1.0, 1.0), // magenta
      vec4(0.0, 1.0, 1.0, 1.0) // cyan
    ];

    point_colors = [];

    triangle_colors = [];

    vBuffer = gl.createBuffer();
    iBuffer = gl.createBuffer();
    cBuffer = gl.createBuffer();

    canvas.addEventListener("mousedown", function(event){

       if (draw_points_on) {

         var x = event.clientX; // x coordinate of a mouse pointer
         var y = event.clientY; // y coordinate of a mouse pointer
         var rect = event.target.getBoundingClientRect() ;

         x = ((x - rect.left) - canvas.width/2)/(canvas.width/2);
         y = (canvas.height/2 - (y - rect.top))/(canvas.height/2);

         point_vertices = vec4(x,y,0.0,1.0).concat(point_vertices);
         //console.log(pointIndex);
         //point_colors = canvas_colors[pointIndex].concat(point_colors);
         //console.log(canvas_colors[pointIndex]);
         point_colors = vec4(1.0,0.0,1.0,1.0).concat(point_colors);

         /*
         gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer);
         gl.bufferSubData(gl.ARRAY_BUFFER, sizeof['vec2']*point_index,flatten(vec2(x,y)));

         var t = vec4(point_colors[pointIndex]);

         gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
         gl.bufferSubData(gl.ARRAY_BUFFER, sizeof['vec4']*point_index, flatten(t));

         point_vertices.push(index);

         point_index++;
         index++;

         render();
         */

       }
       else if (draw_triangle_on) {

         var x = event.clientX; // x coordinate of a mouse pointer
         var y = event.clientY; // y coordinate of a mouse pointer
         var rect = event.target.getBoundingClientRect() ;

         x = ((x - rect.left) - canvas.width/2)/(canvas.width/2);
         y = (canvas.height/2 - (y - rect.top))/(canvas.height/2);

         gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer);
         gl.bufferSubData(gl.ARRAY_BUFFER, sizeof['vec2']*(triangle_index),flatten(vec2(x,y)));

         var t = vec4(triangle_colors[triangleIndex]);

         gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
         gl.bufferSubData(gl.ARRAY_BUFFER, sizeof['vec4']*(triangle_index), flatten(t));

         console.log("click");
         triangle_index++;

         if (triangle_index%3==0 && triangle_index != 0)
         {
            triangle_vertices.push(index);
            index += 3;
            render();
         }

       }



   } );


    drawScene();

}

function initBuffer(mode) {

    gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);

    if (mode == "TRIANGLE_MODE") {
        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuffer);
    }

    aPosition = gl.getAttribLocation( program, "aPosition" );
    gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
    aColor = gl.getAttribLocation(program, "aColor");
    gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false,0,0) ;
    gl.enableVertexAttribArray(aColor)
}

function bindBuffer(mode) {
    /*========== Bind Buffers =======*/
    if (mode == "TRIANGLE_MODE") {
        gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle_vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangle_indices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle_colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    } else if (mode == "POINT_MODE") {
        gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point_vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(point_colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
}

function drawScene()
{
  gl.viewport( 0.0, 0.0, canvas.width, canvas.height );
  gl.clearColor(0.3921, 0.5843, 0.9294, 1.0);
  //gl.clearColor(canvas_colors[canvas_index][0], canvas_colors[canvas_index][1],
  //    canvas_colors[canvas_index][2], 1.0);
  gl.clear( gl.COLOR_BUFFER_BIT );

  if (triangle_vertices.length > 2) {
        bindBuffer("TRIANGLE_MODE");
        initBuffer("TRIANGLE_MODE");
        gl.drawArrays(gl.TRIANGLES, 0, triangle_indices.length, gl.UNSIGNED_SHORT, 0);
  }
  if (point_vertices.length > 2) {
      bindBuffer("POINT_MODE");
      initBuffer("POINT_MODE");
      gl.drawArrays(gl.POINTS, 0, point_vertices.length / 3);
  }
  requestAnimFrame(drawScene);
}


function clear_canvas()
{
    index = 0;
    point_index = 0;
    triangle_index = 0;
    point_vertices = [];
    triangle_vertices = [];
    gl.viewport( 0.0, 0.0, canvas.width, canvas.height );
    gl.clearColor(canvas_colors[canvas_index][0], canvas_colors[canvas_index][1],
        canvas_colors[canvas_index][2], 1.0);
    gl.clear( gl.COLOR_BUFFER_BIT );
}

function draw_triangle()
{
  if (draw_triangle_on) {
    console.log("Triangle OFF");
    draw_triangle_on = false;
  } else {
    console.log("Triangle ON");
    draw_triangle_on = true;
  }
}


function draw_points()
{
  if (draw_points_on) {
    console.log("Points OFF");
    draw_points_on = false;
  } else {
    console.log("Points ON");
    draw_points_on = true;
  }
}

</script>
